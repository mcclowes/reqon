// Multi-Source Data Synchronization Mission
// ============================================
// This mission demonstrates the recommended file structure:
// - schemas/<entity>/schema.reqon - Schema definitions
// - schemas/<entity>/transform.reqon - Transform definitions
// - mission.reqon - Main mission file that imports and orchestrates
// ============================================

mission MultiSourceSync {
  schedule: every 1 hours

  // ============================================
  // SOURCES - API Connections
  // ============================================

  source Xero {
    auth: oauth2,
    base: "https://api.xero.com/api.xro/2.0"
  }

  source Stripe {
    auth: bearer,
    base: "https://api.stripe.com/v1"
  }

  source Shopify {
    auth: api_key,
    base: "https://mystore.myshopify.com/admin/api/2024-01"
  }

  // ============================================
  // STORES - Data Storage
  // ============================================

  store orders: file("unified-orders")
  store payments: file("unified-payments")
  store errors: file("sync-errors")
  store raw_orders: memory("raw_orders")

  // ============================================
  // SCHEMAS - imported from schema files
  // (In production, use import statements)
  // ============================================

  // Order schemas
  schema XeroInvoice {
    InvoiceID: string,
    InvoiceNumber: string,
    Contact: { ContactID: string, Name: string },
    Total: decimal,
    CurrencyCode: string,
    Date: date,
    Status: string
  }

  schema StripeCharge {
    id: string,
    amount: int,
    currency: string,
    created: int,
    status: string,
    metadata: any?
  }

  schema ShopifyOrder {
    id: string,
    order_number: string,
    total_price: string,
    currency: string,
    created_at: string,
    financial_status: string,
    customer: { id: string, email: string? }
  }

  schema UnifiedOrder {
    id: string,
    source: string,
    external_id: string,
    customer_ref: string?,
    amount: decimal,
    currency: string,
    status: string,
    created_at: date,
    synced_at: date
  }

  // Error schemas
  schema RateLimitError { message: string, retryAfter: int? }
  schema AuthError { error: string, code: string }

  // ============================================
  // TRANSFORMS - Reusable transformation logic
  // ============================================

  // Overloaded transform: automatically selects the right mapping
  // based on the source schema of the input data
  transform ToUnifiedOrder {
    (XeroInvoice) -> UnifiedOrder {
      id: "order-xero-" + .InvoiceID,
      source: "xero",
      external_id: .InvoiceID,
      customer_ref: .Contact.ContactID,
      amount: .Total,
      currency: .CurrencyCode,
      status: match .Status {
        "AUTHORISED" => "confirmed",
        "PAID" => "paid",
        "VOIDED" => "cancelled",
        _ => "pending"
      },
      created_at: .Date,
      synced_at: now()
    }

    (StripeCharge) -> UnifiedOrder {
      id: "order-stripe-" + .id,
      source: "stripe",
      external_id: .id,
      customer_ref: .metadata.customer_id ?? null,
      amount: .amount / 100,
      currency: .currency,
      status: match .status {
        "succeeded" => "paid",
        "pending" => "pending",
        "failed" => "failed",
        _ => "unknown"
      },
      created_at: fromUnix(.created),
      synced_at: now()
    }

    (ShopifyOrder) -> UnifiedOrder {
      id: "order-shopify-" + .id,
      source: "shopify",
      external_id: .id,
      customer_ref: .customer.id,
      amount: parseDecimal(.total_price),
      currency: .currency,
      status: match .financial_status {
        "paid" => "paid",
        "pending" => "pending",
        "refunded" => "refunded",
        _ => "unknown"
      },
      created_at: parseDate(.created_at),
      synced_at: now()
    }

    // Wildcard fallback for unknown formats
    (_) -> UnifiedOrder {
      id: "order-unknown-" + (.id ?? generateId()),
      source: "unknown",
      external_id: .id ?? "",
      customer_ref: null,
      amount: .amount ?? .total ?? 0,
      currency: .currency ?? "USD",
      status: "unknown",
      created_at: now(),
      synced_at: now()
    }
  }

  // ============================================
  // ACTIONS - Processing Steps
  // ============================================

  action FetchXeroOrders {
    get "/Invoices" from Xero {
      paginate: { type: page, param: "page", pageSize: 100 },
      since: lastSync
    }

    match response {
      RateLimitError -> retry { backoff: exponential, maxAttempts: 3 }
      AuthError -> abort "Xero authentication failed"
      _ -> continue
    }

    for invoice in response.Invoices {
      store invoice -> raw_orders { key: .InvoiceID, upsert: true }
    }
  }

  action FetchStripeOrders {
    get "/charges" from Stripe {
      paginate: { type: cursor, param: "starting_after", pageSize: 100, cursorPath: "data[-1].id" },
      since: lastSync
    }

    match response {
      RateLimitError -> retry { backoff: exponential, maxAttempts: 3 }
      AuthError -> abort "Stripe authentication failed"
      _ -> continue
    }

    for charge in response.data {
      store charge -> raw_orders { key: .id, upsert: true }
    }
  }

  action FetchShopifyOrders {
    get "/orders.json" from Shopify {
      paginate: { type: page, param: "page", pageSize: 250 },
      since: lastSync
    }

    match response {
      RateLimitError -> retry { backoff: exponential, maxAttempts: 3 }
      AuthError -> abort "Shopify authentication failed"
      _ -> continue
    }

    for order in response.orders {
      store order -> raw_orders { key: .id, upsert: true }
    }
  }

  action NormalizeOrders {
    for order in raw_orders {
      // The transform automatically selects the right variant
      // based on schema matching
      apply ToUnifiedOrder to order

      // Validate the transformed data
      validate response {
        assume .id is string,
        assume .amount is decimal,
        assume .amount >= 0
      }

      // Store the unified order
      store response -> orders { key: .id, upsert: true }
    }
  }

  // ============================================
  // PIPELINE - Execution Order
  // ============================================

  // Fetch from all sources in parallel, then normalize
  run [FetchXeroOrders, FetchStripeOrders, FetchShopifyOrders] then NormalizeOrders
}
