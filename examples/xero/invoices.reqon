// Xero Invoice Sync Mission
// Fetches all invoices from Xero, hydrates them, and normalizes to a standard schema

mission SyncXeroInvoices {
  // Define the API source
  source Xero {
    auth: oauth2,
    base: "https://api.xero.com/api.xro/2.0"
  }

  // Define storage destinations
  store invoices_cache: sql("invoices")
  store invoices_normalized: sql("invoices_normalized")

  // Step 1: Fetch list of invoices (shallow/summary data)
  action FetchInvoiceList {
    fetch GET "/Invoices" {
      paginate: offset(page, 100),
      until: length(response.Invoices) == 0
    }

    validate response {
      assume length(.Invoices) > 0
    }

    store response.Invoices -> invoices_cache {
      key: .InvoiceID,
      partial: true
    }
  }

  // Step 2: Hydrate each invoice with full details
  action HydrateInvoices {
    for invoice in invoices_cache where ._partial == true {
      fetch GET "/Invoices/{invoice.InvoiceID}"

      validate response {
        assume length(.Invoices) == 1
      }

      store response.Invoices -> invoices_cache {
        key: .InvoiceID,
        partial: false,
        upsert: true
      }
    }
  }

  // Step 3: Map to standard schema
  action NormalizeInvoices {
    for invoice in invoices_cache {
      map invoice -> StandardInvoice {
        id: .InvoiceID,
        vendor: "xero",
        external_id: .InvoiceNumber,
        amount: .Total,
        currency: .CurrencyCode,
        status: match .Status {
          "PAID" => "paid",
          "AUTHORISED" => "approved",
          "SUBMITTED" => "pending",
          "DRAFT" => "draft",
          _ => "unknown"
        },
        issued_at: .Date,
        due_at: .DueDate,
        customer_name: .Contact.Name,
        line_items_count: length(.LineItems)
      }

      validate response {
        assume .amount >= 0
      }

      store response -> invoices_normalized {
        key: .id
      }
    }
  }

  // Pipeline: run actions in sequence
  run FetchInvoiceList
    then HydrateInvoices
    then NormalizeInvoices
}
